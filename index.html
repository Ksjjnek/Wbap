<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mega Mine Slot</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; color: #fff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; }
        canvas { display: block; background: #2c3e50; flex-grow: 1; touch-action: none; }
        .hud { position: absolute; top: 10px; width: 100%; display: flex; justify-content: space-around; pointer-events: none; }
        .stat { background: rgba(0,0,0,0.6); padding: 5px 15px; border-radius: 20px; border: 1px solid #555; font-weight: bold; color: #ffcc00; }
        .controls { height: 100px; background: #333; display: flex; align-items: center; justify-content: center; border-top: 4px solid #555; }
        button { 
            background: linear-gradient(to bottom, #5aab44 0%, #3e7a2f 100%);
            border: none; border-bottom: 4px solid #2d5a22; border-radius: 12px;
            color: white; padding: 15px 40px; font-size: 20px; font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); cursor: pointer; transition: 0.1s;
        }
        button:active { transform: translateY(2px); border-bottom-width: 2px; }
    </style>
</head>
<body>

<div id="game-container">
    <div class="hud">
        <div class="stat">üíé <span id="coins">0</span></div>
        <div class="stat">‚ö° <span id="energy">100</span></div>
    </div>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button onclick="spin()">SPIN!</button>
    </div>
</div>

<script>
const tg = window.Telegram.WebApp;
tg.expand();
tg.enableClosingConfirmation();

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const coinsEl = document.getElementById('coins');

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã
const COLS = 5;
const ROWS = 9;
let cellSize = 0;
let coins = 0;
let shake = 0;

// –¶–≤–µ—Ç–∞ –±–ª–æ–∫–æ–≤
const COLORS = {
    DIRT: '#8B4513', STONE: '#707070', TNT: '#ff4d4d', 
    CHEST: '#d4a017', IRON: '#ced4da', DIAMOND: '#00f2ff'
};

let grid = [];
let entities = []; // –ö–∏—Ä–∫–∏ –∏ —á–∞—Å—Ç–∏—Ü—ã

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.life = 1.0;
        this.color = color;
    }
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 5, 5);
        ctx.globalAlpha = 1;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.vy += 0.5; // –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
        this.life -= 0.04;
    }
}

class Pickaxe {
    constructor(col, type) {
        this.col = col;
        this.type = type; // 'iron' –∏–ª–∏ 'diamond'
        this.y = 0;
        this.speed = 0.15;
        this.power = (type === 'diamond') ? 3 : 1;
        this.color = COLORS[type.toUpperCase()];
    }
    draw() {
        ctx.save();
        ctx.translate(this.col * cellSize + cellSize/2, this.y * cellSize);
        ctx.fillStyle = this.color;
        // –ü—Ä–æ—Å—Ç–∞—è —Ñ–æ—Ä–º–∞ –∫–∏—Ä–∫–∏
        ctx.fillRect(-15, 0, 30, 8);
        ctx.fillRect(-4, 0, 8, 25);
        ctx.restore();
    }
}

function initGrid() {
    grid = [];
    for(let r=0; r<ROWS; r++) {
        grid[r] = [];
        for(let c=0; c<COLS; c++) {
            let type = 'DIRT';
            if (r > 3) type = Math.random() > 0.8 ? 'STONE' : 'DIRT';
            if (Math.random() > 0.95) type = 'TNT';
            if (r === ROWS - 1) type = 'CHEST';
            grid[r][c] = { type, hp: (type==='STONE'? 2 : 1), active: true };
        }
    }
}

function createExplosion(x, y, color) {
    for(let i=0; i<10; i++) entities.push(new Particle(x, y, color));
}

function explodeTNT(r, c) {
    shake = 15;
    tg.HapticFeedback.notificationOccurred('warning');
    for(let i = -1; i <= 1; i++) {
        for(let j = -1; j <= 1; j++) {
            if(grid[r+i] && grid[r+i][c+j]) {
                let b = grid[r+i][c+j];
                if(b.active) {
                    b.active = false;
                    createExplosion((c+j)*cellSize + cellSize/2, (r+i)*cellSize + cellSize/2, '#ffcc00');
                }
            }
        }
    }
}

function spin() {
    tg.HapticFeedback.impactOccurred('medium');
    for(let c=0; c<COLS; c++) {
        if(Math.random() > 0.4) {
            let type = Math.random() > 0.8 ? 'diamond' : 'iron';
            entities.push(new Pickaxe(c, type));
        }
    }
}

function update() {
    if(shake > 0) shake *= 0.9;

    entities.forEach((ent, index) => {
        if(ent instanceof Particle) {
            ent.update();
            if(ent.life <= 0) entities.splice(index, 1);
        }
        if(ent instanceof Pickaxe) {
            ent.y += ent.speed;
            let r = Math.floor(ent.y);
            let b = grid[r] ? grid[r][ent.col] : null;

            if(b && b.active) {
                if(b.type === 'TNT') {
                    explodeTNT(r, ent.col);
                    entities.splice(index, 1);
                } else {
                    b.hp -= ent.power;
                    createExplosion(ent.col * cellSize + cellSize/2, ent.y * cellSize, COLORS[b.type]);
                    if(b.hp <= 0) {
                        b.active = false;
                        if(b.type === 'CHEST') {
                            coins += 50;
                            coinsEl.innerText = coins;
                            tg.HapticFeedback.notificationOccurred('success');
                        }
                    }
                    if(ent.type === 'iron') entities.splice(index, 1);
                }
            }
            if(ent.y > ROWS) entities.splice(index, 1);
        }
    });
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    if(shake > 1) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);

    // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É –±–ª–æ–∫–æ–≤
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            let b = grid[r][c];
            if(!b.active) continue;

            let x = c * cellSize;
            let y = r * cellSize;

            // –¢–µ–ª–æ –±–ª–æ–∫–∞
            ctx.fillStyle = COLORS[b.type];
            ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);

            // "–ü–∏–∫—Å–µ–ª—å–Ω–∞—è" —Ç–µ–∫—Å—Ç—É—Ä–∞ (–≥—Ä—è–∑—å/–∫–∞–º–µ–Ω—å)
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(x+5, y+5, 10, 10);
            ctx.fillRect(x+cellSize-15, y+cellSize-15, 8, 8);
            
            // –ï—Å–ª–∏ –∫–∞–º–µ–Ω—å –ø—Ä–æ—á–Ω—ã–π - —Ä–∏—Å—É–µ–º —Ç—Ä–µ—â–∏–Ω—É
            if(b.hp > 1) {
                ctx.strokeStyle = 'black';
                ctx.beginPath(); ctx.moveTo(x+10, y+10); ctx.lineTo(x+cellSize-10, y+cellSize-10); ctx.stroke();
            }
        }
    }

    entities.forEach(ent => ent.draw());
    ctx.restore();

    update();
    requestAnimationFrame(draw);
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 100;
    cellSize = canvas.width / COLS;
    initGrid();
}

window.addEventListener('resize', resize);
resize();
draw();

</script>
</body>
</html>
