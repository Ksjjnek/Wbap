<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice App with Menu</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #0f0f0f; font-family: 'Inter', sans-serif; color: white; }
        
        /* –ü—Ä–æ—Ñ–∏–ª—å (–≤–∏–¥–µ–Ω –≤–µ–∑–¥–µ) */
        #user-header {
            position: absolute; top: 20px; left: 20px;
            display: flex; align-items: center; gap: 10px;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(15px);
            padding: 8px 16px; border-radius: 40px; z-index: 200;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #user-photo { width: 32px; height: 32px; border-radius: 50%; border: 1px solid #fff; }

        /* –ú–ï–ù–Æ */
        #menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.5s;
        }
        .game-card {
            width: 280px; height: 320px;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-radius: 24px; position: relative;
            box-shadow: 0 15px 35px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.05);
            overflow: hidden;
        }
        .card-preview {
            width: 100%; height: 65%; background: #222;
            display: flex; align-items: center; justify-content: center;
            font-size: 100px; text-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        .card-title {
            position: absolute; bottom: 25px; left: 20px;
            font-size: 26px; font-weight: 800; letter-spacing: 1px;
        }
        .play-btn {
            position: absolute; bottom: 20px; right: 20px;
            padding: 12px 24px; font-size: 14px; font-weight: bold;
            background: #fff; color: #000; border: none; border-radius: 30px;
            cursor: pointer; box-shadow: 0 5px 15px rgba(255,255,255,0.2);
            transition: 0.2s;
        }
        .play-btn:active { transform: scale(0.9); }

        /* –ò–ì–†–û–í–û–ô –≠–ö–†–ê–ù (–°–∫—Ä—ã—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é) */
        #game-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; z-index: 50;
        }
        #three-canvas-container { position: absolute; width: 100%; height: 100%; z-index: -1; }
        
        #result-screen {
            position: absolute; top: 15%; width: 100%; text-align: center;
            pointer-events: none; opacity: 0; transition: all 0.4s ease-out;
        }
        #result-screen.show { opacity: 1; transform: scale(1.1); }
        #result-label { font-size: 12px; text-transform: uppercase; letter-spacing: 4px; opacity: 0.5; }
        #result-value { font-size: 80px; font-weight: 900; display: block; line-height: 1; color: #fff; }

        #roll-button {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            padding: 18px 60px; font-size: 16px; font-weight: bold; border-radius: 50px;
            border: none; background: #ffffff; color: #000; cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); transition: 0.3s;
        }
        #roll-button:active { transform: translateX(-50%) scale(0.9); }
        #roll-button.hide { opacity: 0; pointer-events: none; transform: translateX(-50%) translateY(20px); }

        /* –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥ */
        #back-btn {
            position: absolute; top: 25px; right: 20px;
            padding: 8px 16px; font-size: 14px; border-radius: 20px;
            background: rgba(255,255,255,0.1); color: #fff; border: none;
            cursor: pointer; backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>

    <div id="user-header">
        <img id="user-photo" src="" alt="" style="display:none;">
        <div id="user-name">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    </div>

    <div id="menu-screen">
        <div class="game-card">
            <div class="card-preview">üé≤</div>
            <div class="card-title">–ö—É–±–∏–∫</div>
            <button class="play-btn" id="start-game-btn">–ò–≥—Ä–∞—Ç—å</button>
        </div>
    </div>

    <div id="game-screen">
        <div id="three-canvas-container"></div>
        <button id="back-btn">–ù–∞–∑–∞–¥</button>
        
        <div id="result-screen">
            <span id="result-label">–í—ã–ø–∞–ª–æ</span>
            <span id="result-value">0</span>
        </div>
        <button id="roll-button">–ë–†–û–°–ò–¢–¨</button>
    </div>

    <script>
        // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø TELEGRAM ---
        const tg = window.Telegram.WebApp;
        tg.expand();
        
        if (tg.initDataUnsafe?.user) {
            const user = tg.initDataUnsafe.user;
            document.getElementById('user-name').innerText = user.first_name;
            if (user.photo_url) {
                const img = document.getElementById('user-photo');
                img.src = user.photo_url; img.style.display = 'block';
            }
        }

        // --- –õ–û–ì–ò–ö–ê –ú–ï–ù–Æ ---
        const menuScreen = document.getElementById('menu-screen');
        const gameScreen = document.getElementById('game-screen');
        let gameInitialized = false;

        document.getElementById('start-game-btn').onclick = () => {
            tg.HapticFeedback.impactOccurred('light');
            menuScreen.style.opacity = '0';
            setTimeout(() => {
                menuScreen.style.display = 'none';
                gameScreen.style.display = 'block';
                if (!gameInitialized) {
                    init3D();
                    gameInitialized = true;
                }
            }, 300); // –ü–ª–∞–≤–Ω–æ–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ –º–µ–Ω—é
        };

        document.getElementById('back-btn').onclick = () => {
            tg.HapticFeedback.impactOccurred('light');
            gameScreen.style.display = 'none';
            menuScreen.style.display = 'flex';
            setTimeout(() => menuScreen.style.opacity = '1', 50);
        };

        // --- –õ–û–ì–ò–ö–ê 3D –ò–ì–†–´ ---
        let scene, camera, renderer, dice;
        let isRolling = false;

        const diceRotations = {
            1: { x: 0, y: -Math.PI/2, z: 0 },
            6: { x: 0, y: Math.PI/2, z: 0 },
            2: { x: Math.PI/2, y: 0, z: 0 },
            5: { x: -Math.PI/2, y: 0, z: 0 },
            3: { x: 0, y: 0, z: 0 },
            4: { x: 0, y: Math.PI, z: 0 }
        };

        function init3D() {
            const container = document.getElementById('three-canvas-container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1.4);
            light.position.set(5, 10, 5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));

            const geometry = new THREE.BoxGeometry(2.2, 2.2, 2.2, 6, 6, 6);
            
            const createFace = (dotsCount) => {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#333333';
                ctx.beginPath();
                ctx.roundRect(0, 0, 256, 256, 60);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                const pips = {
                    1: [[128, 128]],
                    2: [[70, 70], [186, 186]],
                    3: [[70, 70], [128, 128], [186, 186]],
                    4: [[70, 70], [186, 70], [70, 186], [186, 186]],
                    5: [[70, 70], [186, 70], [128, 128], [70, 186], [186, 186]],
                    6: [[70, 70], [186, 70], [70, 128], [186, 128], [70, 186], [186, 186]]
                };

                pips[dotsCount].forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p[0], p[1], 24, 0, Math.PI * 2);
                    ctx.fill();
                });

                return new THREE.MeshStandardMaterial({ 
                    map: new THREE.CanvasTexture(canvas),
                    transparent: true, opacity: 0.95, roughness: 0.1
                });
            };

            const materials = [
                createFace(1), createFace(6), 
                createFace(2), createFace(5), 
                createFace(3), createFace(4) 
            ];

            dice = new THREE.Mesh(geometry, materials);
            
            // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å—Ç–∞–≤–∏–º –∫—É–±–∏–∫ –Ω–∞ –µ–¥–∏–Ω–∏—á–∫—É
            dice.rotation.set(diceRotations[1].x, diceRotations[1].y, diceRotations[1].z);
            scene.add(dice);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        const btn = document.getElementById('roll-button');
        const resScreen = document.getElementById('result-screen');
        const resVal = document.getElementById('result-value');

        btn.onclick = () => {
            if (isRolling) return;
            isRolling = true;
            btn.classList.add('hide');
            resScreen.classList.remove('show');
            tg.HapticFeedback.impactOccurred('heavy');

            const result = Math.floor(Math.random() * 6) + 1;
            const target = diceRotations[result];

            // –¢–æ—Ç —Å–∞–º—ã–π —Ñ–∏–∫—Å! –ë–µ—Ä–µ–º —á–∏—Å—Ç—ã–µ –±–∞–∑–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è —Å—Ç–∞—Ä—Ç–∞ –∞–Ω–∏–º–∞—Ü–∏–∏
            const startX = dice.rotation.x;
            const startY = dice.rotation.y;
            const startZ = dice.rotation.z;

            // –ö—É–±–∏–∫ —Å–¥–µ–ª–∞–µ—Ç —Ä–æ–≤–Ω–æ 6 –æ–±–æ—Ä–æ—Ç–æ–≤ (–æ—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ)
            const extraSpins = 6 * Math.PI * 2; 
            const finalRotation = {
                x: target.x + extraSpins,
                y: target.y + extraSpins,
                z: target.z + extraSpins
            };

            const duration = 2000; // –°–¥–µ–ª–∞–ª–∏ –±—ã—Å—Ç—Ä–µ–µ: 2 —Å–µ–∫—É–Ω–¥—ã –≤–º–µ—Å—Ç–æ 3.5
            const startTime = Date.now();

            const roll = () => {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                
                // –§—É–Ω–∫—Ü–∏—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏ (Ease Out)
                const ease = 1 - Math.pow(1 - t, 4);

                dice.rotation.x = startX + (finalRotation.x - startX) * ease;
                dice.rotation.y = startY + (finalRotation.y - startY) * ease;
                dice.rotation.z = startZ + (finalRotation.z - startZ) * ease;

                // –ë—ã—Å—Ç—Ä—ã–π –ø—Ä—ã–∂–æ–∫
                dice.position.y = Math.sin(t * Math.PI) * 2;

                if (t < 1) {
                    requestAnimationFrame(roll);
                } else {
                    finish(result);
                }
            };

            requestAnimationFrame(roll);
        };

        function finish(result) {
            isRolling = false;
            
            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ë–ê–ì–ê –ó–ê–ú–ï–î–õ–ï–ù–ò–Ø: 
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ª–∏—à–Ω–∏–µ –≥—Ä–∞–¥—É—Å—ã, –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —á–∏—Å—Ç—É—é –ø–æ–∑–∏—Ü–∏—é –≤—ã–ø–∞–≤—à–µ–π –≥—Ä–∞–Ω–∏.
            // –≠—Ç–æ –≤–∏–∑—É–∞–ª—å–Ω–æ –Ω–µ –∑–∞–º–µ—Ç–Ω–æ, –Ω–æ –¥–ª—è –∫–æ–¥–∞ —Å–ª–µ–¥—É—é—â–∏–π –±—Ä–æ—Å–æ–∫ –Ω–∞—á–Ω–µ—Ç—Å—è —Å "–Ω—É–ª—è" –ø–æ–ª–Ω—ã—Ö –æ–±–æ—Ä–æ—Ç–æ–≤.
            dice.rotation.set(diceRotations[result].x, diceRotations[result].y, diceRotations[result].z);

            resVal.innerText = result;
            resScreen.classList.add('show');
            tg.HapticFeedback.notificationOccurred('success');
            setTimeout(() => btn.classList.remove('hide'), 800);
        }

        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
